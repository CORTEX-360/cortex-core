<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORTEX 360 | True Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Noto+Sans+Symbols&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        body { background-color: #f8fafc; font-family: 'Roboto', sans-serif; color: #334155; }
        .canvas-container { 
            margin: 0 auto 40px auto; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            background-color: white;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <header class="h-16 bg-white border-b border-slate-200 flex items-center justify-between px-8 z-20 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-1.5 rounded font-bold text-sm">C360</div>
            <h1 class="font-medium text-slate-700">Editor <span class="text-blue-600 font-bold">Pro</span> <span class="text-xs text-slate-400 ml-2">v4.0 Redaction</span></h1>
        </div>
        <div id="main-toolbar" class="hidden">
            <button onclick="savePDF()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg text-sm font-bold shadow-md transition flex items-center gap-2">
                <span class="material-icons text-sm">save</span> Salvar PDF
            </button>
        </div>
    </header>

    <main class="flex-1 overflow-y-auto bg-slate-100 p-8 flex flex-col items-center" id="workspace">
        
        <div id="upload-card" class="mt-20 max-w-lg w-full bg-white p-12 rounded-2xl shadow-xl text-center cursor-pointer hover:scale-[1.01] transition-transform border border-slate-200" onclick="document.getElementById('file-input').click()">
            <span class="material-icons text-6xl text-blue-500 mb-4">cloud_upload</span>
            <h2 class="text-2xl font-bold text-slate-800 mb-2">Carregar PDF</h2>
            <p class="text-slate-500">Clique para editar com Supressão Real</p>
            <input type="file" id="file-input" accept="application/pdf" class="hidden" onchange="handleFileUpload(this)">
        </div>

        <div id="loader" class="hidden mt-20 flex flex-col items-center">
            <div class="w-12 h-12 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mb-4"></div>
            <p class="text-slate-600 font-medium animate-pulse">Analisando vetores...</p>
        </div>

        <div id="canvas-wrapper" class="hidden flex flex-col gap-8 w-full max-w-5xl pb-20"></div>

    </main>

    <script>
        const API_URL = "https://72.60.244.132:8082"; 
        let pdfDoc = null;
        let fabricCanvases = [];
        let pdfData = null;

        async function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            document.getElementById('upload-card').classList.add('hidden');
            document.getElementById('loader').classList.remove('hidden');

            try {
                const formData = new FormData();
                formData.append("file", file);
                
                const response = await fetch(`${API_URL}/analyze`, { method: 'POST', body: formData });
                if (!response.ok) throw new Error("Erro na API");
                pdfData = await response.json();

                const fileURL = URL.createObjectURL(file);
                pdfDoc = await pdfjsLib.getDocument(fileURL).promise;
                
                document.getElementById('loader').classList.add('hidden');
                document.getElementById('canvas-wrapper').classList.remove('hidden');
                document.getElementById('main-toolbar').classList.remove('hidden');

                await renderEditor();

            } catch (e) {
                alert("Erro: " + e.message);
                location.reload();
            }
        }

        async function renderEditor() {
            const container = document.getElementById('canvas-wrapper');
            container.innerHTML = '';
            fabricCanvases = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const scale = 1.5;
                const viewport = page.getViewport({ scale: scale });

                const wrapper = document.createElement('div');
                wrapper.className = "relative mx-auto";
                container.appendChild(wrapper);

                const canvasEl = document.createElement('canvas');
                canvasEl.id = `page-${i}`;
                wrapper.appendChild(canvasEl);

                const ctx = canvasEl.getContext('2d');
                canvasEl.height = viewport.height;
                canvasEl.width = viewport.width;

                await page.render({ canvasContext: ctx, viewport: viewport }).promise;

                const fabricCanvas = new fabric.Canvas(`page-${i}`, {
                    width: viewport.width, height: viewport.height, selection: false
                });

                const bgURL = canvasEl.toDataURL("image/png");
                fabric.Image.fromURL(bgURL, img => {
                    img.set({ width: viewport.width, height: viewport.height, selectable: false, evented: false });
                    fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
                });

                const pageData = pdfData.pages[i-1];
                if (pageData?.text_objects) {
                    pageData.text_objects.forEach(obj => {
                        
                        const textObj = new fabric.IText(obj.text, {
                            left: (obj.x * scale) - 1,
                            top: (obj.y * scale) - 1,
                            fontSize: obj.size * scale,
                            fontFamily: obj.fontFamily || 'Arial',
                            fill: '#000000',
                            backgroundColor: 'transparent',
                            editable: true,
                            hasControls: false,
                            hasBorders: true,
                            borderColor: 'transparent',
                            padding: 2,
                            cursorColor: '#2563eb'
                        });

                        // DADOS ORIGINAIS PARA SUPRESSÃO
                        textObj.set('origText', obj.text);
                        textObj.set('paperColor', obj.detectedBg || '#ffffff');
                        
                        // *** O PULO DO GATO ***
                        // Guardamos a largura/altura ORIGINAL para mandar pro backend apagar tudo
                        textObj.set('origWidth', obj.width); 
                        textObj.set('origHeight', obj.height); 

                        // Eventos Visuais
                        textObj.on('mouseover', function() {
                            if (!this.isEditing) this.set('borderColor', '#94a3b8');
                            fabricCanvas.renderAll();
                        });
                        textObj.on('mouseout', function() {
                            if (!this.isEditing) this.set('borderColor', 'transparent');
                            fabricCanvas.renderAll();
                        });
                        
                        // Ao editar, fundo fica da cor do papel para facilitar leitura
                        textObj.on('editing:entered', function() {
                            this.set('backgroundColor', this.paperColor);
                        });
                        textObj.on('editing:exited', function() {
                            // Se mudou, mantém fundo. Se igual, transparente.
                            if (this.text !== this.origText) {
                                this.set('backgroundColor', this.paperColor);
                            } else {
                                this.set('backgroundColor', 'transparent');
                            }
                            fabricCanvas.renderAll();
                        });

                        fabricCanvas.add(textObj);
                    });
                }
                fabricCanvases.push(fabricCanvas);
            }
        }

        async function savePDF() {
            const btn = document.querySelector('#main-toolbar button');
            const originalLabel = btn.innerHTML;
            btn.innerHTML = 'Processando...';
            btn.disabled = true;

            const modifications = [];
            const fileInput = document.getElementById('file-input');

            fabricCanvases.forEach((canvas, index) => {
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'i-text') {
                        // Salva se o texto mudou
                        if (obj.text !== obj.origText) {
                            modifications.push({
                                pageIndex: index,
                                objects: [{
                                    text: obj.text,
                                    left: (obj.left + 1) / 1.5,
                                    top: (obj.top + 1) / 1.5,
                                    width: obj.width * obj.scaleX / 1.5, // Largura do NOVO texto
                                    height: obj.height * obj.scaleY / 1.5,
                                    fontSize: obj.fontSize / 1.5,
                                    fontFamily: obj.fontFamily,
                                    fontWeight: obj.fontWeight,
                                    
                                    // Enviamos a cor do papel para preencher o buraco da redação
                                    backgroundColor: obj.paperColor,
                                    
                                    // *** INFORMAMOS O TAMANHO ORIGINAL PARA APAGAR ***
                                    eraseWidth: obj.origWidth,
                                    eraseHeight: obj.origHeight
                                }]
                            });
                        }
                    }
                });
            });

            if (modifications.length === 0) {
                alert("Nenhuma alteração detectada.");
                btn.innerHTML = originalLabel;
                btn.disabled = false;
                return;
            }

            const formData = new FormData();
            formData.append("file", fileInput.files[0]);
            formData.append("modifications", JSON.stringify(modifications));

            try {
                const res = await fetch(`${API_URL}/sign`, { method: 'POST', body: formData });
                if (!res.ok) throw new Error("Erro no processamento do servidor");
                const blob = await res.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = "Documento_Editado_C360.pdf";
                document.body.appendChild(a); a.click(); a.remove();
            } catch (e) {
                alert("Erro: " + e.message);
            } finally {
                btn.innerHTML = originalLabel;
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>